# Tool

a [[tool]] can be defined as a [[set]] of edges in a [[graph]] whose vertices are _"things"_ and edges represent that one "thing" _is required for_ another "thing"

> **example** using nails is required for building a chair. a hammer is a tool that drives nails; it allows the use of nails for building a chair

## Scope

notice that many [[tool]]s match one of the following _scopes_

0. _[[tool]]_ does _X_ for _Y_
1. _[[tool]]_ does _X_ for "everything"
2. _[[tool]]_ does "everything" for _Y_
3. _[[tool]]_ does "everything" for "everything"

> **examples**
>
> - a hammer drives nails for "everything"
> - [[vim]] does text editing for "everything"
> - Visual Studio does "everything" for [[c++]] development
> - IntelliJ does "everything" for [[java]] development
> - VS Code does "everything" for "everything"
> - Obsidian does "everything" for [[conceptual note-taking]]
> - `gdb` does debugging for "everything"
> - Unity does "everything" for [[video game]] development
> - LibreOffice Writer does "everything" for word processing

[[learning]] to use a [[tool]] is an [[invest]]ment; understanding a [[tool]]'s _scope_ is essential for deciding whether [[invest]]ing in [[learning]] to use it is worth it. type-0 and type-3 [[tool]]s are relatively uncommon. type-1 and type-2 [[tool]]s are common yet very different. skills with type-1 [[tool]]s are generally **transferable**, and type-1 [[tool]]s are **composable** but potentially **less efficient**. conversely, skills with type-2 [[tool]]s are generally **not transferable**, and type-2 [[tool]]s are **specialized** but potentially **more efficient**

> **note**
>
> I prefer type-1 [[tool]]s over type-2 [[tool]]s because I highly value composition and transferability; efficiency I make up for through practice and customization
>
> Obsidian is a type-2 [[tool]] that is great at some things and not so great at others &mdash; <https://youtu.be/nz99I7apNLI>. regardless, from my point of view, none of this matters because most of the features it has (or lacks for that matter) are solved problems:
>
> - Obsidian has good search &mdash; but search is a solved problem; ripgrep is great at it
> - Obsidian has great autocomplete &mdash; but autocomplete is a solved problem; [[vim]] and VS Code are great at it
> - Obsidian has first-party file syncing &mdash; but file syncing is a solved problem; Git and Syncthing are great at it
> - Obsidian lacks file access control. but file access control is a solved problem; Nextcloud and ownCloud are great at it
> - Obsidian has a paid [[markdown]]-to-web service &mdash; but [[markdown]]-to-web is a solved problem; mkdocs and hugo are great at it
> - Obsidian lacks support for team collaboration &mdash; but team collaboration is a solved problem; Git and GitHub are great at it
> - Obsidian is good at text manipulation &mdash; but text manipulation is a solved problem; [[vim]] bindings are great at it
> - Obsidian is phenomenal for linking &mdash; but linking is a solved problem; [[markdown]] and [[wikilink]]s are great at it
