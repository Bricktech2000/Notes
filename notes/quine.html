<!DOCTYPE html>
<!-- saved from url=(0049)http://www.madore.org/~david/computers/quine.html -->
<html xml:lang="en" lang="en" xmlns="http://www.w3.org/1999/xhtml"><!-- This file is automatically generated.  Do not edit! --><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta content="width=device-width, initial-scale=1" name="viewport">
<link href="http://www.madore.org/~david/favicon.ico" rel="Shortcut Icon">
<title>Quines (self-replicating programs)</title>
<meta content="Some thoughts and explanations about quines (self-printing computer programs) and related concepts" name="Description">
<meta content="computers, computer science, Quine, self-rep, Douglas Hofstadter, Scheme" name="Keywords">
<style type="text/css">
/* <![CDATA[ */
/* Put horizontal margin around html rather than body, so we can use
   auto on the later. */
html { margin: 0px 8px; }
body {
  color: black;
  font-family: Optima, "Zapf Humanist", Palatino, "Palatino Linotype", serif;
  margin: 8px auto;
}
h1,h2,h3,h4,h5,h6 {
  font-family: Futura, "Century Gothic", "Avant Garde", "Avant Garde Gothic", Helvetica, Arial, sans-serif;
}
h1 { color: rgb(0,128,0); }
h2 { color: rgb(96,96,0); }
h3 { color: rgb(96,64,0); }
.title { text-align: center; }
.subtitle {
  font-size: 1.5em; text-align: center;
  font-family: Futura, "Century Gothic", "Avant Garde", "Avant Garde Gothic", Helvetica, Arial, sans-serif;
  color: rgb(24,96,0);
}
article { display: block; }
.navbar {
  display: block;
  font-size: .83em;
  font-family: "Times Roman", Times, "Times New Roman", serif;
}
.important { font-weight: bold; border: solid; padding: 1em; }
.outset { border: outset; padding-left: 0.5em; padding-right: 0.5em; }
.sidenote { font-size: .83em; }
.weblog-entry-headlink { color: rgb(128,64,0); }
.weblog-entry-headlink > a { color: inherit; }
.weblog-entry-title {
  color: black;
  font-size: 1.17em;
  font-weight: bold;
  font-family: Futura, "Avant Garde", Helvetica, Arial, sans-serif;
}
.talkback-link {
  color: rgb(128,64,0); font-size: 0.83em; text-align: right;
  font-family: Futura, "Avant Garde", Helvetica, Arial, sans-serif;
  margin-bottom: 0pt;
}
.talkback-link > a { color: inherit; }
.categories-list {
  color: rgb(128,64,0); font-size: 0.83em; text-align: right;
  font-family: Futura, "Avant Garde", Helvetica, Arial, sans-serif;
  margin-bottom: 0pt;
}
.categories-list > a { color: inherit; }
.cut-link {
  font-family: Futura, "Avant Garde", Helvetica, Arial, sans-serif;
}
.sitemap-note {
  font-style: italic;
  color: rgb(96,0,0);
}
.idlist > dt { color: rgb(96,64,0); }
.numtable td { text-align: right; }
.noparskip p { margin-top: 0; margin-bottom: 0; }
.cleared { clear: both; }
.cleared-left { clear: left; }
.cleared-right { clear: right; }
.pic { float: left; margin-right: 1em; margin-bottom: 1em; }
.pic-right { float: right; margin-left: 1em; margin-bottom: 1em; }
.pic-embed { float: left; margin-right: 1em; margin-bottom: 1em; margin-top: 1em; }
.pic-embed-right { float: right; margin-left: 1em; margin-bottom: 1em; margin-top: 1em; }
.max40 { max-width: 40%; height: auto; }
.max60 { max-width: 60%; height: auto; }
.max100 { max-width: 100%; height: auto; }
.smiley { vertical-align: middle; }
.centered { text-align: center; }
.separated { margin-top: 2.33em; }
.unicode-name { font-family: sans-serif; font-size: .83em; }
.keypoint { padding-left: 40%; font-size: .83em; font-weight: bolder; text-align: right; }
.subpoint { padding-left: 40%; font-size: .83em; text-align: right; }
a { text-decoration: none; }
:lang(en) > q { quotes: "\201C" "\201D" "\2018" "\2019"; }
:lang(fr) > q { quotes: "\AB\A0" "\A0\BB" "\201C" "\201D"; }
:lang(de) > q { quotes: "\201E" "\201C" "\201A" "\2018"; }
q:before { content: open-quote; }
q:after { content: close-quote; }
li { -moz-float-edge: content-box; } /* Undo Mozilla buggy bugware! */
pre { overflow: auto; } /* Avoid unreadable code because lines are too short */
/* For despammed email addresses */
@media all { /* Hide from various buggy browsers! */
  .replace-commercial-at:before { content: "@"; }
  .replace-commercial-at > img { display: none; }
  .replace-full-stop:before { content: "."; }
  .replace-full-stop > img { display: none; }
  .replace-plus-sign:before { content: "+"; }
  .replace-plus-sign > img { display: none; }
}
/* Screen-specific rules */
@media screen {
  html { background: rgb(192,208,224); }
  .navbar {
    background: rgb(224,192,192);
    border: solid; border-color: rgb(224,0,0);
    padding: 1em;
    float: right; margin-left: 1.33em;
  }
  .important {
    background: rgb(208,208,208);
    border-color: rgb(255,0,0);
  }
  .weblog-entry {
    background: rgb(224,224,192);
    border: solid; border-color: rgb(128,64,0);
    padding: 1em; margin-bottom: 1em;
    overflow: hidden;
  }
  .outset { background: rgb(192,224,208); }
  .ffii-call { background: rgb(192,224,208); }
  :link { color: rgb(0,0,192); }
  :visited { color: rgb(96,0,192); }
  .weblog-internal-link:link,.weblog-internal-link:visited { color: rgb(0,64,192); }
  :link:hover,:visited:hover { text-decoration: underline; }
}
@media (max-width: 640px) {
  body { --default-size: 12px;  font-size: 12px;  --default-margin: 15px; }
  .weblog-entry { padding: .3em; }
  .pic { margin-right: .3em; margin-bottom: .3em; }
  .pic-right { margin-left: .3em; margin-bottom: .3em; }
  .pic-embed { margin-right: .3em; margin-bottom: .3em; margin-top: .3em; }
  .pic-embed-right { margin-left: .3em; margin-bottom: .3em; margin-top: .3em; }
  html { margin: 0px 6px; }
  body { margin: 6px auto; }
  ul, ol { padding-inline-start: 15px; }
  blockquote { margin-inline: 15px; }
}
@media (min-width: 641px) and (max-width: 780px) {
  body { --default-size: 14px;  font-size: 14px;  --default-margin: 20px; }
  .weblog-entry { padding: .5em; }
  .pic { margin-right: .5em; margin-bottom: .5em; }
  .pic-right { margin-left: .5em; margin-bottom: .5em; }
  .pic-embed { margin-right: .5em; margin-bottom: .5em; margin-top: .5em; }
  .pic-embed-right { margin-left: .5em; margin-bottom: .5em; margin-top: .5em; }
  html { margin: 0px 7px; }
  body { margin: 7px auto; }
  ul, ol { padding-inline-start: 20px; }
  blockquote { margin-inline: 20px; }
}
@media (min-width: 781px) {
  body { --default-size: 16px;  font-size: 16px;  --default-margin: 40px; }
}
@media print {
  .navbar { display: none; }
}
/* ]]> */
</style>
<script type="text/javascript">
// <![CDATA[
"use strict";

var textNodeType;

function textContent(n) {
    "use strict";
    if ( n.nodeType == textNodeType ) {
	return n.data;
    } else {
	var children = n.childNodes;
	var t = "";
	for ( var i=0 ; i<children.length ; i++ ) {
	    t = t.concat(textContent(children.item(i)));
	}
	return t;
    }
}

function despam() {
    "use strict";
    // MSIE seems to barf...  Deactivate for now
    if ( (/MSIE *[1-6]\./).test(navigator.userAgent) )
	return;
    // Now replace as appropriate.
    var elts = document.getElementsByTagName("span");
    for ( var i=0 ; i<elts.length ; i++ ) {
	var elt = elts.item(i);
	if ( elt.className == "replace-commercial-at" ) {
	    elt.parentNode.replaceChild(document.createTextNode("@"),elt);
	    i--;  // Semi-bugware
	} else if ( elt.className == "replace-full-stop" ) {
	    elt.parentNode.replaceChild(document.createTextNode("."),elt);
	    i--;  // Semi-bugware
	} else if ( elt.className == "replace-plus-sign" ) {
	    elt.parentNode.replaceChild(document.createTextNode("+"),elt);
	    i--;  // Semi-bugware
	}
    }
    // Merge adjacent text nodes.
    try {
	document.normalize();  // Your DOM is BROKEN!
    } catch (exn) {
	document.documentElement.normalize();
    }
    // Next, process all <a> elements having class="despammed-address".
    elts = document.getElementsByTagName("a");
    for ( var i=0 ; i<elts.length ; i++ ) {
	var elt = elts.item(i);
	if ( elt.className == "despammed-address" ) {
	    var addr = "mailto:".concat(textContent(elt));
	    elt.setAttribute("href",addr);  // (abstract)
	    elt.href = addr;  // (semantic)
	}
    }
}

function showFontSize() {
    "use strict";
    var showDftSize = document.getElementById("js-show-default-font-size");
    var showCurSize = document.getElementById("js-show-current-font-size");
    var dftSize = getComputedStyle(document.body).getPropertyValue("--default-size");
    if ( ! dftSize )
	dftSize = "unknown";
    var curSize = document.body.style.fontSize;
    if ( ! curSize )
	curSize = dftSize;
    if ( showCurSize )
	showCurSize.textContent = curSize;
    if ( showDftSize )
	showDftSize.textContent = dftSize;
}

function setFontSize(size) {
    "use strict";
    if ( size == "reset" ) {
	localStorage.removeItem("preferredFontSize");
	document.body.style.fontSize = "";
    } else if ( size == null ) {
	var prfSize = localStorage.getItem("preferredFontSize");
	if ( prfSize != null ) {
	    document.body.style.fontSize = prfSize;
	}
    } else {
	localStorage.setItem("preferredFontSize", size);
	document.body.style.fontSize = size;
    }
    showFontSize();
}

function showMaxWidth() {
    "use strict";
    var showCurSize = document.getElementById("js-show-current-max-width");
    var curSize = document.body.style.maxWidth;
    if ( ! curSize )
	curSize = "infinite";
    if ( showCurSize )
	showCurSize.textContent = curSize;
}

function setMaxWidth(size) {
    "use strict";
    if ( size == "reset" ) {
	localStorage.removeItem("preferredMaxWidth");
	document.body.style.maxWidth = "";
    } else if ( size == null ) {
	var prfSize = localStorage.getItem("preferredMaxWidth");
	if ( prfSize != null ) {
	    document.body.style.maxWidth = prfSize;
	}
    } else {
	localStorage.setItem("preferredMaxWidth", size);
	document.body.style.maxWidth = size;
    }
    showMaxWidth();
}

function fillJSFoot() {
    "use strict";
    var jsFoot = document.getElementById("js-foot-space");
    if ( jsFoot == null )
	return;
    var html_ns = "http://www.w3.org/1999/xhtml";
    jsFoot.parentNode.insertBefore(document.createElementNS(html_ns, "hr"), jsFoot.nextSibling);
    // Site settings:
    var settingsOutDiv = document.createElementNS(html_ns, "div");
    settingsOutDiv.setAttributeNS(null, "lang", "en");
    jsFoot.appendChild(settingsOutDiv);
    var showSettingsP = document.createElementNS(html_ns, "p");
    settingsOutDiv.appendChild(showSettingsP);
    var showSettingsButton = document.createElementNS(html_ns, "button");
    showSettingsP.appendChild(showSettingsButton);
    showSettingsButton.appendChild(document.createTextNode("\u2699"));
    showSettingsP.appendChild(document.createTextNode("\u00A0\u2190\u00A0Click for site settings"));
    var settingsInDiv = document.createElementNS(html_ns, "div");
    settingsInDiv.setAttributeNS(null, "id", "js-site-settings");
    settingsOutDiv.appendChild(settingsInDiv);
    settingsInDiv.style.display = "none";
    showSettingsButton.onclick = (function (visible) { return function(evt) {
	visible = ! visible;
	settingsInDiv.style.display = visible ? "" : "none";
	if ( visible ) { settingsInDiv.scrollIntoView(); }
    }; })(false);
    // Font size setting:
    var fontSizeP = document.createElementNS(html_ns, "p");
    fontSizeP.setAttributeNS(null, "lang", "en");
    settingsInDiv.appendChild(fontSizeP);
    fontSizeP.appendChild(document.createTextNode("Change site font size (current: "));
    var showCurSize = document.createElementNS(html_ns, "span");
    showCurSize.setAttributeNS(null, "id", "js-show-current-font-size");
    fontSizeP.appendChild(showCurSize);
    fontSizeP.appendChild(document.createTextNode("): "));
    var sizeList = [ "reset", "8px", "9px", "10px", "11px", "12px", "13px", "14px", "15px", "16px", "17px", "18px", "19px", "20px", "22px", "24px", "26px", "28px", "30px", "32px" ];
    for ( var i=0 ; i<sizeList.length ; i++ ) {
	if ( i > 0 )
	    fontSizeP.appendChild(document.createTextNode(", "));
	var size = sizeList[i];
	var clicker = document.createElementNS(html_ns, "button");
	fontSizeP.appendChild(clicker);
	clicker.appendChild(document.createTextNode(size));
	var makesf = function(size) { return (function(evt) {
	    setFontSize(size); settingsInDiv.scrollIntoView(); }); };
	clicker.onclick = makesf(size);
	if ( size == "reset" ) {
	    fontSizeP.appendChild(document.createTextNode(" (default: "));
	    var showDftSize = document.createElementNS(html_ns, "span");
	    showDftSize.setAttributeNS(null, "id", "js-show-default-font-size");
	    fontSizeP.appendChild(showDftSize);
	    fontSizeP.appendChild(document.createTextNode(")"));
	} else {
	    fontSizeP.appendChild(document.createTextNode("\u00A0"));
	    var demo = document.createElementNS(html_ns, "span");
	    fontSizeP.appendChild(demo);
	    demo.style.fontSize = size;
	    demo.appendChild(document.createTextNode("(Aa)"));
	}
    }
    showFontSize();
    addEventListener("resize", function(event) { showFontSize(); });
    // Line size setting:
    var lineSizeP = document.createElementNS(html_ns, "p");
    lineSizeP.setAttributeNS(null, "lang", "en");
    settingsInDiv.appendChild(lineSizeP);
    lineSizeP.appendChild(document.createTextNode("Change site line size (current: "));
    var showCurSize = document.createElementNS(html_ns, "span");
    showCurSize.setAttributeNS(null, "id", "js-show-current-max-width");
    lineSizeP.appendChild(showCurSize);
    lineSizeP.appendChild(document.createTextNode("): "));
    var sizeList = [ "reset", "50ch", "60ch", "70ch", "80ch", "90ch", "100ch", "110ch", "120ch", "130ch", "140ch", "150ch", "160ch", "infinite" ];
    for ( var i=0 ; i<sizeList.length ; i++ ) {
	if ( i > 0 )
	    lineSizeP.appendChild(document.createTextNode(", "));
	var size = sizeList[i];
	var clicker = document.createElementNS(html_ns, "button");
	lineSizeP.appendChild(clicker);
	clicker.appendChild(document.createTextNode(size));
	var makesf = function(size) { return (function(evt) {
	    setMaxWidth(size); settingsInDiv.scrollIntoView(); }); };
	clicker.onclick = makesf(size == "infinite" ? "" : size);
	if ( size == "reset" ) {
	    lineSizeP.appendChild(document.createTextNode(" (default: infinite)"));
	}
    }
    showMaxWidth();
}

function onEarly() {  // This function is run as soon as <body> is created
    "use strict";
    // Start with some bugware...
    try {
	textNodeType = Node.TEXT_NODE;
    } catch (exn) {  // Your DOM is BROKEN!
	textNodeType = 3;
    }
    // Select user-preferred font and line size
    setFontSize();
    setMaxWidth();
}

function onLoad() {  // This function is run when page is loaded
    "use strict";
    // Now despam email adresses.
    despam();
    // Fill JavaScript-based footer.
    fillJSFoot();
}
// ]]>
</script>
</head>
<body onload="if (onLoad) { onLoad(); }">
<script type="text/javascript">if (onEarly) { onEarly(); }</script>
<header>
<hgroup>
<h1 class="title">Quines (self-replicating programs)</h1>
</hgroup>
<nav class="navbar"><a href="http://www.madore.org/~david/">David Madore</a><br><a href="http://perso.enst.fr/madore/">Prof. site</a><br><a href="http://www.madore.org/~david/">Site Root</a><br><a href="http://www.madore.org/~david/sitemap.html">Site Map</a><br><a href="http://www.madore.org/~david/weblog/">WebLog</a></nav>
</header>

<h2 id="sec_toc">Table of contents</h2>

<ul>
<li><a href="http://www.madore.org/~david/computers/quine.html#sec_whatis">What is a quine?  What is this page?</a></li>
<li><a href="http://www.madore.org/~david/computers/quine.html#sec_intro">Introduction</a></li>
<li><a href="http://www.madore.org/~david/computers/quine.html#sec_first">A first attempt and example</a></li>
<li><a href="http://www.madore.org/~david/computers/quine.html#sec_princ">Principles for writing a quine</a></li>
<li><a href="http://www.madore.org/~david/computers/quine.html#sec_second">A second example: added clarity</a></li>
<li><a href="http://www.madore.org/~david/computers/quine.html#sec_fp">The fixed-point theorem</a></li>
<li><a href="http://www.madore.org/~david/computers/quine.html#sec_multiquine">Multi-quines: making use of
introns</a></li>
<li><a href="http://www.madore.org/~david/computers/quine.html#sec_bootstrap">Bootstrapping: recovering the code from
the data</a></li>
<li><a href="http://www.madore.org/~david/computers/quine.html#sec_recap">Recapitulation</a></li>
<li><a href="http://www.madore.org/~david/computers/quine.html#sec_selfint">Self-interpretation: using data as
code</a></li>
<li><a href="http://www.madore.org/~david/computers/quine.html#sec_conc">Conclusion</a></li>
<li><a href="http://www.madore.org/~david/computers/quine.html#sec_links">Links related to quines</a></li>
</ul>


<h2 id="sec_whatis">What is a quine?  What is this page?</h2>

<p>A “<dfn>quine</dfn>” (or “<dfn>selfrep</dfn>”)
is a computer program which prints its own listing.  This may sound
either impossible, or trivial, or completely uninteresting, depending
on your temper and your knowledge of computer science.  Actually, it
is possible, and there are some interesting ideas involved (in
particular, writing a quine is <em>not</em> a hack that only works
because the programming language has certain nice properties —
it is a consequence of the general so-called <a href="http://www.madore.org/~david/computers/quine.html#sec_fp">“fixed-point” theorem</a>, itself an
instance of Cantor's ubiquitous diagonal argument).</p>

<p>Quines are so named after the American mathematician and logician
Willard van Orman Quine (1908/06/25–2000/12/25) who introduced
the concept.  This page is dedicated to his memory.</p>

<p>I also dedicate this page to Douglas R. Hofstadter, who coined the
name (in his justly famous book <cite>Gödel, Escher, Bach</cite>) and
who so clearly explained quines' importance and their relation with
Gödel's incompleteness theorem.</p>


<h2 id="sec_intro">Introduction</h2>

<p>A quine is a program which prints its own listing.  This means that
when the program is <em>run</em>, it must print out precisely those
instructions which the programmer wrote as part of the program
(including, of course, the instructions that do the printing, and the
data used in the printing).</p>

<p>The easiest way to do that, of course, is to seek the source file on
the disk, open it, and print its contents.  That may be done, but it
is considered cheating; besides, the program might not know where the
source file is, it may have access to only the compiled data, or the
programming language may simply forbid that sort of operations.</p>

<p>The interesting thing is that writing a quine does not depend on any
kind of hack such as being able to read a source file, or even being
able to represent quotes in several different ways.  <em>Any</em>
programming language which is Turing complete, and which is able to
output any string (by a computable function of the string as program
— this is a technical condition that is satisfied in every
programming language in existence) has a quine program (and, in fact,
infinitely many quine programs, and many similar curiosities) as
follows by the <a href="http://www.madore.org/~david/computers/quine.html#sec_fp">fixed-point theorem</a>.  Moreover,
the fixed-point theorem is constructive, so the construction of the
quine is merely a matter of patience, not guesswork (or intelligence
as some prefer to call it&nbsp;;-).  This is not to imply, of course, that
actually writing a <em>short</em> or <em>interesting</em> quine may
not demand a lot of cleverness.  Still, it says that there is nothing
“<em>magical</em>” behind quines; and also nothing says that they
have to be obfuscated, difficult to read, or devoid of comments, as
they often are.</p>


<h2 id="sec_first">A first attempt and example</h2>

<p>We try writing a quine in C.  We choose C because it is widely known,
and also because the <code>printf()</code> function has features which
will make writing a quine considerably easier (this is a mixed
blessing: it is a gain because it makes the quine smaller, but it also
makes it sensibly more obscure and “hackish”).</p>

<p>We will want the quine to be correct C code, so it will probably have
to begin something like this:</p>

<pre>#include &lt;stdio.h&gt;

int
main (void)
{
</pre>

<p>The first thing we want to do is print all what precedes.  Naïvely, we
could write:</p>

<pre>  printf("#include &lt;stdio.h&gt;\n\nint\nmain (void)\n{\n");
</pre>

<p>Then we need to print this line itself:</p>

<pre>  printf("printf(\"#include &lt;stdio.h&gt;\\n\\nint\\nmain (void)\\n{\\n\");\n");
</pre>

<p>And so on.  It should be obvious that this is not going to work
(except if we intend to produce a quine of infinite length, which we
do not).</p>

<p>This is the sort of reasoning which makes some people believe that
quines don't exist.  The problem is that we need to print something,
so we use a character string (say <var>s</var>) to print it, and then
we need to print <var>s</var> itself, so we use another character
string, and so on…</p>

<p>But wait!  If we intend to print <var>s</var>, we <em>don't</em> need
another string: we can use <var>s</var> itself.  So let's give it
another try:</p>

<pre>  char *s="#include &lt;stdio.h&gt;\n\nint\nmain (void)\n{\n";
  printf(s);  printf("char *s=\"%s\";\n",s);
</pre>

<p>Well, it still doesn't work.  But we have introduced one of the <a href="http://www.madore.org/~david/computers/quine.html#sec_princ">central ideas</a> in quine-writing lore:
<strong>whereas it is probably necessary to use some data to represent
the code to be printed, on the other hand it is possible to reuse
these data to print the data themselves</strong>.  Here we're still a
bit naïve: we're using <var>s</var> “as it stands”, but that won't
work because it contains some backslashes; these would need to be
further backslashified.  So we have two paths before us: the King's
way is to proceed with backslashification, which will work because
this is a computable process.  However, since we are writing in C, we
choose a shortcut which uses the nice properties of the printf
function:</p>

<pre>  char *s1="#include &lt;stdio.h&gt;%c%cint%cmain (void)%c{%c";
  char *s2="  char *s1=%c%s%c;%c  char *s2=%c%s%c;%c";
  char n='\n', q='"';
  printf(s1,n,n,n,n,n);
  printf(s2,q,s1,q,n,q,s2,q,n);
</pre>

<p>This is a partial quine: it prints the beginning of its own listing
(something in no way remarkable, since any program which doesn't print
anything is a “partial quine”).  Here we have passed the
“catching up point”, by this I mean that the program data
printed includes the data representation itself.  It is then generally
trivial to complete the quine (here, things are still a bit tricky
because we've been doing things in a more or less <i>ad hoc</i>
manner, and some of the data are actually hidden in the
<code>printf()</code> statements.  Nevertheless, it is not very
difficult to finish:</p>

<pre>#include &lt;stdio.h&gt;

int
main (void)
{
  char *s1="#include &lt;stdio.h&gt;%c%cint%cmain (void)%c{%c";
  char *s2="  char *s%c=%c%s%c;%c  char *s%c=%c%s%c;%c";
  char *s3="  char n='%cn', q='%c', b='%c%c';%c";
  char *sp="  printf(";
  char *s4="%ss1,n,n,n,n,n);%c";
  char *s5="%ss2,'1',q,s1,q,n,'2',q,s2,q,n);%ss2,'3',q,s3,q,n,'p',q,sp,q,n);%c";
  char *s6="%ss2,'4',q,s4,q,n,'5',q,s5,q,n);%ss2,'6',q,s6,q,n,'7',q,s7,q,n);%c";
  char *s7="%ss2,'8',q,s8,q,n,'9',q,s9,q,n);%ss2,'0',q,s0,q,n,'x',q,sx,q,n);%c";
  char *s8="%ss3,b,q,b,b,n);%ss4,sp,n);%ss5,sp,sp,n);%c";
  char *s9="%ss6,sp,sp,n);%ss7,sp,sp,n);%ss8,sp,sp,sp,n);%c";
  char *s0="%ss9,sp,sp,sp,n);%ss0,sp,sp,n,n,n);%c  return 0;%c}%c";
  char *sx="--- This is an intron. ---";
  char n='\n', q='"', b='\\';
  printf(s1,n,n,n,n,n);
  printf(s2,'1',q,s1,q,n,'2',q,s2,q,n);  printf(s2,'3',q,s3,q,n,'p',q,sp,q,n);
  printf(s2,'4',q,s4,q,n,'5',q,s5,q,n);  printf(s2,'6',q,s6,q,n,'7',q,s7,q,n);
  printf(s2,'8',q,s8,q,n,'9',q,s9,q,n);  printf(s2,'0',q,s0,q,n,'x',q,sx,q,n);
  printf(s3,b,q,b,b,n);  printf(s4,sp,n);  printf(s5,sp,sp,n);
  printf(s6,sp,sp,n);  printf(s7,sp,sp,n);  printf(s8,sp,sp,sp,n);
  printf(s9,sp,sp,sp,n);  printf(s0,sp,sp,n,n,n);
  return 0;
}
</pre>

<p>Here we have a real quine (if you find it obscure, do not worry, much
clearer examples will be given further below).  Note the use of the
<code>s2</code> string to print several lines modeled on the same
pattern.  Also note how the backslash required no special treatment.
And note the <code>sx</code> string which goes to show that the
classical belief that everything in a quine must be doubled, is false
(the meaning of the term “intron”, which comes from molecular
biology, will be made clearer <a href="http://www.madore.org/~david/computers/quine.html#rmk_intron">below</a>).</p>

<p>This quine is intermediate in elegance: on the one hand it does not
assume that the computer is using an ASCII character set (you see a
lot of C quines which use the fact that double quotes have ASCII code
34 and that line feed has code 10), it is valid ANSI C (with a
warning, however, to the fact that I should have written “<code>const
char *</code>” rather than just “<code>char *</code>”; this is much
better than many quines which omit the <code>return 0</code> at the
end or similar things), and the longest lines are just 80 characters
(often quines have terribly long lines).  On the other hand, the
formatting is inelegant: don't conclude from the above example that
quines need be so badly presented.  Also, nothing says you can't have
comments within quines.  We will give much <a href="http://www.madore.org/~david/computers/quine.html#sec_second">more
elegant</a> examples later.</p>


<h2 id="sec_princ">Principles for writing a quine</h2>

<p>The basic idea is this:</p>

<blockquote>

<p>It is impossible (in most programming languages) for a program to
manipulate itself (i.e. its textual representation — or a
representation from which its textual representation can be easily
derived) directly.</p>

<p>So to make this possible anyway, we write the build the program from
two parts, one which call the <em>code</em> and one which we call the
<em>data</em>.  The data represents (the textual form of) the code,
and it is derived in an algorithmic way from it (mostly, by putting
quotation marks around it, but sometimes in a slightly more
complicated way).  The code uses the data to print the code (which is
easy because the data represents the code); then it uses the data to
print the data (which is possible because the data is obtained by an
algorithmic transformation from the code).</p>

</blockquote>

<p>This idea is summarized by the sentence “quine
‘quine’”.  Here, the verb <dfn>to quine</dfn>
(invented by Douglas R. Hofstadter) means “to write (a sentence
fragment) a first time, and then to write it a second time, but with
quotation marks around it” (for example, if we quine
“say”, we get “say ‘say’”).  Thus,
if we quine “quine”, we get “quine
‘quine’”, so that the sentence “quine
‘quine’” is a quine… In this linguistic
analogy, the verb “to quine”, plays the role of the code,
and “quine” in quotation marks plays the role of the data.</p>

<p>We will henceforth use the words “code” and “data” a lot, to
designate the code and data parts of the quine as just explained.</p>

<p id="rmk_bioana">If we are to take an analogy with cellular
biology (thanks to Douglas Hofstadter again), what I have called
the “code” would be the cell, and the “data” would be the cell's
DNA: the cell is able to create a new cell using the DNA, and this
involves, among other things, replicating the DNA itself.  So the DNA
(the data) contains all the necessary information for the replication,
but without the cell (the code), or at least some other code to make
the data live, it is a useless, inert, piece of data.</p>

<p id="rmk_intron">Note how the data may contain (depending on
how it's interpreted) bits that aren't used to write the code, but are
still copied when the data is written on the output.  Such bits are
called <em>introns</em>, in analogy with the parts of the genome
which aren't used to produce proteins.  The example we gave above had
an intro (the string <code>sx</code>), clearly marked as such.  Quite
obviously an intron can be modified with great ease; it is a kind of
subliminal information that is reproduced with the quine, although it
is not necessary to the quine.  The possible existence of introns will
be the key feature making <a href="http://www.madore.org/~david/computers/quine.html#sec_multiquine"><em>multi-quines</em> (something we will talk
about later)</a> possible.</p>

<p>One word of warning: this code/data distinction in quines is pleasant
and often helpful.  It is not, however, completely valid in all
circumstances.  Sometimes the code and the data are not well
distinguised, sometimes part of the code plays a data role, or vice
versa.  Some quines are far beyond my own modest understanding —
and beyond my feeble attempts at classification and order.  As in all
things, <i>caveat emptor</i>.  See <a href="http://www.madore.org/~david/computers/quine.html#rmk_codedata">this
remark</a> later in the text, however.</p>


<h2 id="sec_second">A second example: added clarity</h2>

<p>We now use the <a href="http://www.madore.org/~david/computers/quine.html#sec_princ">principles</a> outlined above to
construct anoter quine, one which will be more elegant in its
formating (but a bit less portable because we will assume an ASCII
coding of characters).</p>

<p>This time, we gather all the data in one place, one array containing
the ASCII values of the characters making up the code, and we place
this array at the beginning of the program.  The code will use the
array to first print the array (by printing it as a list of
hexadecimal integers with a proper formatting) and then print the code
(by converting the ASCII values to characters).</p>

<p>This is completely straightforward, and while this quine is far from
the shortest, I think it is the clearest I have ever seen:</p>

<pre>/* See comments below */

const unsigned char data[] = {
/* 000000 */  0x2f,  0x2a,  0x20,  0x54,  0x68,  0x69,  0x73,  0x20,
/* 0x0008 */  0x69,  0x73,  0x20,  0x61,  0x20,  0x73,  0x65,  0x6c,
/* 0x0010 */  0x66,  0x72,  0x65,  0x70,  0x20,  0x28,  0x71,  0x75,
/* 0x0018 */  0x69,  0x6e,  0x65,  0x29,  0x20,  0x70,  0x72,  0x6f,
<i>/* Several lines snipped.  See <a href="http://www.madore.org/~david/programs/selfrep/selfprt.c">the original file</a> for a complete listing. */</i>
/* 0x02c0 */  0x20,  0x28,  0x64,  0x61,  0x74,  0x61,  0x5b,  0x69,
/* 0x02c8 */  0x5d,  0x29,  0x3b,  0x0a,  0x20,  0x20,  0x72,  0x65,
/* 0x02d0 */  0x74,  0x75,  0x72,  0x6e,  0x20,  0x30,  0x3b,  0x0a,
/* 0x02d8 */  0x7d,  0x0a,
};

/* This is a selfrep (quine) program.  It uses the above data (which
 * is no other than the ASCII representation of everything starting
 * from this comment) to print its own listing. */

#include &lt;stdio.h&gt;

int
main (void)
     /* The main program.  We output the data in the format used at
      * the top of this file, and then we use it to generate the rest
      * of this file. */
{
  unsigned int i;

  printf ("/* See comments below */\n\n");
  printf ("const unsigned char data[] = {");
  for ( i=0 ; i&lt;sizeof(data) ; i++ )
    {
      if ( i%8 == 0 )
	printf ("\n/* %0#6x */",i);
      printf ("  %0#4x,", data[i]);
    }
  printf ("\n};\n\n");
  for ( i=0 ; i&lt;sizeof(data) ; i++ )
    putchar (data[i]);
  return 0;
}
</pre>

<p>This should make it obvious that there is nothing difficult at all in
writing quines.  In fact this is the sort of quines we obtain by
directly applying the <a href="http://www.madore.org/~david/computers/quine.html#sec_fp">fixed-point theorem</a>.  As
mentioned, the code contains two parts: that which copies the data
(the nine lines following the blank one in the <code>main()</code>
function) and that which uses the data to copy the code (the next two
lines).</p>

<p>Naturally, the coding of the data might be much more complex than a
straightforward ASCII encoding.  We will <a href="http://www.madore.org/~david/computers/quine.html#rmk_coding">return
to that subject</a>.  Also note that here there are no <a href="http://www.madore.org/~david/computers/quine.html#rmk_intron">introns</a>, because ASCII does not permit this
(there are no comments or any such things).  However, we could
trivially add an intron: create a new array, <code>const unsigned char
intron[]</code>, say, put whatever data we want in it, and use the
same printing routines for <code>intron[]</code> as we did for
<code>data[]</code> (of course, we need to modify the code, hence the
data also, to do this, but once it is done, we can put anything in the
intron without modifying anything).</p>

<p>Another point is to be noted: in what precedes I have omitted a great
many lines from the data.  Had I not given a pointer to the original
file, could you have reconstructed the data?  Evidently, yes, and
without much difficulty: just take the code, take the ASCII value of
each character, and tabulate them.  This violates the so-called
<em>Central Dogma</em>, stating that the data must be used (by the
code) to deduce (i.e. to print) the code, but not the converse.  In
practice, though, there is nothing wrong with violating the Central
Dogma, in fact, you can guess that I wrote the program by first
writing the quote and <em>then</em> calculating the data; however,
introns cannot be reconstructed in that way (since the very point
about introns is that all possible data will work).</p>

<p id="rmk_miscode">What if a part of the <em>code</em> had been
missing? Then things are much better off.  For example, if the
comments had been gobbled, running the program itself would have
restored them (from their value encoded in the data).  Even without
any code at all, you would probably have guessed that the data was the
ASCII representation of something and been able to restore the
something in question.  But see the section on <a href="http://www.madore.org/~david/computers/quine.html#sec_bootstrap">bootstrapping</a> for more about this.</p>


<h2 id="sec_fp">The fixed-point theorem</h2>

<p>I have mentioned the fixed-point theorem and stated that it is at the
heart of the existence of quines.  I will now explain what this
theorem states.</p>

<p>(Note that this is just one of very many fixed-point theorems
abounding in mathematics.  This has nothing to do, for example, with
Brouwer's fixed-point theorem.  I don't know that any specific name is
attached to this one, but I suspect it would be something like
<em>Kleene's</em> fixed-point theorem.)</p>

<p>I assume no familiarity with the theory of computability.  However, it
will help: if you are not familiar with it, what I am going to say may
sound a bit vague (but read it anyway, because you probably will grasp
the idea even if the details are obscure).</p>

<p>Before I can state (and prove) the fixed-point theorem, I will recall
some basic notions:</p>

<ul>

<li>A <dfn>computable</dfn> (or “general recursive”) function (of
several integer variables, and with integer values) is one which is
calculated by some program (i.e. some Turing machine operating on the
variables as input, i.e. some algorithm, by whatever definition you
want to take of the word “algorithm” since by the Church-Turing
thesis they're all equivalent).  By a <em>partial</em> function we
mean one which is not necessarily defined on all possible values of
the input variables.  By a <em>total</em> function we mean one which
is.</li>

<li>We need a standard numbering of programs.  This also depends on
the model of computability chosen, but imagine, say, associating with
a program the value obtained by considering the program as the binary
representation of some integer.  We write φ<sub><var>n</var></sub>(…)
for the result of the <var>n</var>-th program when fed the input
represented by the ellipsis.  In particular, any computable function
is equal to φ<sub><var>n</var></sub> for some <var>n</var>.  We will
not distinguish a <em>program</em> from its <em>associated
number</em>.</li>

<li>The <strong>universality theorem</strong> states that the
(partial) function φ<sub><var>n</var></sub>, considered as a
function of <var>n</var> plus its other values, is itself computable.
In other words, there is a <var>u</var> (a <em>universal Turing
machine</em> if you want, or, in simpler terms, an
<em>interpreter</em>) such that
φ<sub><var>u</var></sub>(<var>n</var>…)=φ<sub><var>n</var></sub>(…).
So, effectively, this means that you can construct a program
<var>u</var> that will take a program <var>n</var> and some arguments,
and return the value of <var>n</var> applied to the arguments in
question.  This means that <var>u</var> is an interpreter, which takes
a program and interprets it, so the universality theorem merely states
the existence of an interpreter (of the programming language
considered, written in the programming language considered).  The
universality theorem is a consequence of the Church-Turing thesis,
i.e. our belief that we have grasped all notions of computability.</li>

<li>The <strong>s-m-n theorem</strong> is essentially the converse of
the universality theorem.  It states that if
<var>g</var>(…)=φ<sub>n</sub>(…) is computable then for any
<var>x</var> the function
<var>g</var>(<var>x</var>…)=φ<sub><var>n</var></sub>(x…) (obtained by
fixing the value of one of the input parameters and letting the
remaining vary) is computable <em>and is obtained in a computable way
from&nbsp;<var>n</var></em>.  That is, there exists a (computable, total,
and in fact primitive recursive) function s such that
φ<sub>s(<var>n</var>,<var>x</var>)</sub>(…)=φ<sub><var>n</var></sub>(<var>x</var>…).
This is really a triviality if the numbering is done right (in fact,
it is almost a definition of the fact that the numbering is done
right): it states that if you have a program <var>n</var> taking some
input, you can (for every <var>x</var>) construct a program
s(<var>n</var>,<var>x</var>) that will act as <var>n</var> except that
it takes <var>x</var> as input; moreover, this other program is
derived algorithmically from the first.  So, in effect, you can
substitute a value for an input in a program.</li>

</ul>

<p>Using the s-m-n theorem and the universality theorem we can prove the
fixed-point theorem.  This states that for any computable total
function <var>h</var> there exists an index (a program) <var>n</var>
such that
φ<sub><var>n</var></sub>(…)=φ<sub><var>h</var>(<var>n</var>)</sub>(…).</p>

<p>In plain English, this means that if you have any algorithmic
transformation <var>h</var> on programs then there exists a program
<var>n</var> such that the program <var>n</var> does the same thing as
the program <var>n</var> resulting of the transformation.  We will
explain this with further examples in a second, but first we prove the
statement.</p>

<blockquote>

<p>For a given program <var>t</var>, we consider the program
s(<var>t</var>,<var>t</var>) (given by the s-m-n theorem).  Essentially,
s(<var>t</var>,<var>t</var>) performs what <var>t</var> does when it
is fed itself as input.  We further consider the program
<var>h</var>(s(<var>t</var>,<var>t</var>)) which results from the
tranformation <var>h</var> applied to s(<var>t</var>,<var>t</var>).
Now by the universality theorem, there exists an index <var>m</var>
such that
φ<sub><var>m</var></sub>(<var>t</var>…)=φ<sub><var>h</var>(s(<var>t</var>,<var>t</var>))</sub>(…).
In other words, there is a program <var>m</var> which takes a program
<var>t</var> as input, and performs what the program
<var>h</var>(s(<var>t</var>,<var>t</var>)) does.  Then I claim that
the program <var>n</var>=s(<var>m</var>,<var>m</var>) is the desired
fixed point.  Indeed,
φ<sub><var>n</var></sub>(…)=φ<sub>s(<var>m</var>,<var>m</var>)</sub>(…).
But by definition of <var>s</var>, this is
φ<sub><var>m</var></sub>(m…), which in turn, by definition of
<var>m</var>, is
φ<sub><var>h</var>(s(<var>m</var>,<var>m</var>))</sub>(…)=φ<sub><var>h(</var><var>n</var>)</sub>(…),
<i xml:lang="la" lang="la">quod erat demonstrandum</i>.</p>

</blockquote>

<p>To summarize the proof, we have taken the program <var>m</var> which,
given a program <var>t</var>, interprets the program resulting of
applying the given transformation <var>h</var> to <var>t</var> acting
on itself, and we have applied <em>that</em> program to itself.</p>

<p>How does the fixed-point theorem prove the existence of quines?  This
is very simple: for a given program <var>t</var>, consider the program
<var>h</var>(<var>t</var>) that prints the listing of <var>t</var>.
Obviously this <var>h</var> is computable.  Now the fixed-point
theorem tells us that there is a program <var>n</var> such that
<var>h</var>(<var>n</var>) and <var>n</var> do the same thing,
i.e. printing the listing of <var>n</var>.  So <var>n</var> prints the
listing of <var>n</var>.</p>

<p>In practice, how do we construct <var>n</var>?  Well, the proof of the
fixed-point theorem answers this question as well.  Since the proof
used the universality theorem, it may seem like we need to construct
an interpreter to apply the theorem.  In fact, we need not: indeed, if
you look closely at the proof, you will see that we used the
universality theorem only for programs of the form <var>h</var>(…),
so that we need only construct an interpreter for those programs; for
our particular choice of <var>h</var>, this is trivial.</p>

<p>So consider a program <var>t</var>, taking an argument.  We will
assume that this argument is given as a variable <code>data</code> to
be linked with the program.  Then s(<var>t</var>,<var>t</var>) is the
program obtained by setting this variable <code>data</code> to the
textual value of the program (as a string, say, or as whatever coding
we have chosen).  Our program <var>m</var> takes an argument
<var>t</var> (in the form of the <code>data</code> variable) and
performs what <var>h</var>(s(<var>t</var>,<var>t</var>)) does, i.e. it
prints the listing of s(<var>t</var>,<var>t</var>), which is none
other than the listing of <var>t</var> with a definition of the
variable <code>data</code> to be the text of <var>t</var>.  And
finally for our program <var>n</var> we take
s(<var>m</var>,<var>m</var>), that is, we take this program
<var>m</var> and link the variable <code>data</code> to be the text of
the program.  Quite evidently, this is precisely what we have been
doing.</p>

<p>The fixed-point theorem has other amusing applications.  Essentially,
its intuitive (and effective) content is that a program may use its
own source as a variable, i.e. adding to a programming language the
ability for a program to manipulate itself (its source code) does
<em>not</em> add to its expressive power.  So there exists a program
that compresses its own listing; there exists one which prints its own
MD5 checksum (this is <em>much</em> easier than finding a program
— indeed any file — that <em>contains</em> its MD5
checksum; still, someone I know thought it was impossible except by
brute force — how rude — so I wrote <a href="ftp://ftp.madore.org/pub/madore/misc/selfmd5.c">such a
program</a> and won a bet like that); there exists a program that
prints a second, different, program, that prints the first one again
(here, <var>h</var>(<var>t</var>) would merely be a program that
prints a lot of print calls for the various lines of <var>t</var>'s
listing); and so on.</p>

<p id="rmk_univfp"><small>(A passing note, which you may find a bit
difficult to understand if you're not used to computability theory.)
A different, perhaps more satisfactory, way of
stating the fixed-point theorem would be to eliminate the universality
theorem from it, and to say: for every computable function
<var>k</var> there exists a <var>n</var> such that
φ<sub><var>n</var></sub>(…)=<var>k</var>(n…).  This
corresponds more precisely to the intuitive content we have described.
It is proved <em>without</em> the use of the universality theorem,
using only the s-m-n theorem (for the actual proof, take the proof we
have just given, and replace
φ<sub><var>h</var>(<var>x</var>)</sub>(…) by
<var>k</var>(<var>x</var>…) everywhere).  The advantage of
formulating things like this is we see that it also works for
primitive recursive functions (which satisfy s-m-n but not
universality), so in effect a primitive recursive function can also
make use of its own number.  By applying the universality theorem (the
function φ<sub><var>h</var>(<var>x</var>)</sub>(…) is
computable, so we can call it <var>k</var>(<var>x</var>…)) we
recover the fixed-point theorem as we have stated it.  The examples we
have given of the fixed-point theorem actually use the more restrictive
(non-universal) we have just stated.  The following examples will use
universality (and don't work for primitive recursive functions, which
is clear because primitive recursive functions always
terminate).</small></p>

<p>There also exists a program that <em>interprets</em> its own listing:
we will <a href="http://www.madore.org/~david/computers/quine.html#rmk_selfint">return to this</a>.  Also, if we take
for <var>h</var> the function which to a program <var>x</var>
associates the program which calculates what <var>x</var> does, and,
at the end (provided <var>x</var> terminates, of course) adds 1, we
would have a program <var>x</var> which does the same thing as running
<var>x</var> and adding 1 to the result, and that is only possible if
<var>x</var> does not terminate, so that the fixed-point theorem also
proves the existence of an endless loop.</p>

<p><small><strong>Exercice:</strong> Louis Reasoner believes that the
fixed-point theorem proves the existence of <em>polyglot</em> programs
(i.e. programs that are valid and do the same thing in several
different programming languages).  His argument is this: for a given
program <var>t</var> (in a first programming language) consider a
translation of <var>t</var> in a second programming language, and
interpret this program <em>literally</em> in the first language,
giving <var>h</var>(<var>t</var>).  By the fixed-point theorem, there
exists <var>n</var> such that <var>h</var>(<var>n</var>) and
<var>n</var> have the same effect, i.e. the text of the program
<var>h</var>(<var>n</var>) has the same effect in the first language
(that is <var>h</var>(<var>n</var>)) and in the second (that is
<var>n</var>).  What do you think of this argument?</small></p>

<p><small><strong>Answer to the exercice (in rot13):</strong> <span xml:lang="x-en-rot13" lang="x-en-rot13">Ybhvf vf rffragvnyyl pbeerpg, ohg gurer vf abguvat
cebsbhaq urer.  Gurer vf n uvqqra nffhzcgvba, anzryl gung gur frpbaq
ynathntr vf noyr gb vagrecerg <em>nal</em> cebtenz gung vg vf srq:
gurer vf ab jnl gb erfgevpg gb inyvq cebtenzf (naq pregnvayl vs gur
svefg ynathntr npprcgf bayl cebtenzf ortvaavat jvgu na <code>N</code>
naq gur frpbaq ynathntr bayl cebtenzf ortvaavat jvgu n <code>O</code>,
jr jbhyq unir n uneq gvzr svaqvat n cbyltybg).  Abgvpr gung gur frpbaq
ynathntr qbrfa'g rira unir gb or Ghevat-pbzcyrgr.  Fhowrpg gb gur
vagrecergngvba tvira nobir bs gur svkrq-cbvag gurberz, jung Ybhvf'
nethzrag nzbhagf gb vf guvf: gur cebtenz (jevggra va gur svefg
ynathntr) jvyy eha na vagrecergre bs gur frpbaq ynathntr ba vgf bja
fbhepr pbqr (fbzrguvat jr pna qb gunaxf gb gur svkrq-cbvag gurberz);
abj rivqragyl fhpu n cebtenz qbrf gur fnzr guvat va obgu ynathntrf,
anzryl vagrecerg gur fbhepr pbqr va gur frpbaq ynathntr.  Guvf vf abg
irel hfrshy sbe pbafgehpgvat n P/Crey cbyltybg sbe rknzcyr!</span></small></p>

<p>The fixed-point theorem gives a different point of view on quines from
the one we have given so far.  The <a href="http://www.madore.org/~david/computers/quine.html#sec_princ">ideas</a> we
have already expressed, notably the code/data dichotomy, are perhaps
not very clearly apparent.  Still, they are present: we should
consider the s function from the s-m-n theorem as a mean of <em>adding
data</em> to a program (which would otherwise receive this data as an
input), so the expression s(<var>m</var>,<var>m</var>) which we have
seen says, in effect, add to the program <var>m</var> (the code) a
representation of the program <var>m</var> itself (the data).  <a href="http://www.madore.org/~david/computers/quine.html#rmk_intron">Introns</a> can exist because the function s is
free to add extra data to the data required of it, if it wants.</p>


<h2 id="sec_multiquine">Multi-quines: making use of
introns</h2>

<p>We start by saying what a bi-quine (or more generally a multi-quine)
is.  To begin, here is what it is <em>not</em>: a bi-quine is
<em>not</em> a program which prints a second program, which in turn
prints the first again (actually, it is that, but things are a bit
more subtle).  This is too easy to do (we have proved the existence of
such using <a href="http://www.madore.org/~david/computers/quine.html#sec_fp">the fixed-point theorem</a>): one program
is almost a quine, and the other is merely a sequence of calls to
<code>print</code> the code of the other one.</p>

<p>A multi-quine is also <em>not</em> a polyglot quine (a quine that can
be read, and is a quine, in several different languages).  True,
polyglot quines actually are multi-quines if you think well about it
(the converse is not true), but polyglot quines don't exist for every
combination of programming languages (although it is true that some
people have been incredibly smart at constructing them) whereas
multi-quines do — polyglot quines are a hack whereas
multi-quines are a general phenomenon.</p>

<p>A <dfn>bi-quine</dfn> is a very interesting kind of program: when run
normally, it is a quine.  But if it called with a particular command
line argument, it will print a different program, its “brother”.
Its brother is <em>also</em> a quine, but in a different programming
language, so its brother prints its own listing when run normally.
But when run with a particular command line argument, the brother
prints the listing of the original program.  So in effect, a bi-quine
is a set of two programs each of which is able to print either of the
two.  More generally, a multi-quine is a set of <var>r</var> different
programs (in <var>r</var> different languages — without this
condition we could take them all equal to a single quine), each of
which is able to print any of the <var>r</var> programs (including
itself) according to the command line argument it is passed.  (Note
that cheating is <em>not</em> allowed: the command line arguments must
not be too long — passing the full text of a program <em>is</em>
considered cheating&nbsp;;-).</p>

<p><small>There are several ways to prove the existence of multi-quines using
fixed-point theorems.  Here is one (we leave it to the reader to fill
in the missing details).  We just consider the case of a bi-quine,
i.e. <var>r</var>=2.  We consider, in language 1, a program of two
parameters that will normally print the first, but that will print the
second if a special argument is passed to it.  By the fixed-point
theorem, we can assume that the first text is its own listing, so that
we get a program of one parameter that will print its own listing
except that it will print the parameter if called with a special
argument.  Do the same for language 2.  We now have two programs.
Substitute one in the other: there is a program, of one parameter, in
language 1, that will print its own listing, except when it is called
with a special argument, in which case it will print a program, in
language 2, which prints its own listing except when it is called with
a special argument, in which case it will print the initial parameter
(passed to the first program).  Finally, apply the fixed-point theorem
to <em>that</em>.  <i>Voilà</i>, we have the bi-quine.</small></p>

<p>So, to create multi-quines, we make use of introns (following,
essentially, the proof given just above).  We have <var>r</var>
programs, so <var>r</var> code sets (one in each language); besides,
<em>each</em> of the <var>r</var> programs has, in addition to its
code set, <em><var>r</var></em> data sets, one representing each of
the <var>r</var> code sets (so <var>r</var>-1 of the data sets are
introns as far as the quine structure goes) in a given coding (in
principle it would be possible for <em>each</em> of the
<var>r</var><sup>2</sup> data sets to use a different coding, but
there is no reason to use a different coding for various data sets in
the same program, and even between programs it is reasonable to use
more or less similar codings, at least insofar as the programming
languages allow this).  When program <var>i</var> (running code set
<var>i</var> in language <var>i</var>) is asked to produce the listing
of program <var>j</var>, it will use its <var>j</var>-th data set to
produce the <var>j</var>-th code set, and then it will use
<em>all</em> of its <var>r</var> data sets to produce the <var>r</var>
data sets of program <var>j</var> (coded in the same or in a similar
way).</p>

<p>In practice, we write a quine program similar, say, to the <a href="http://www.madore.org/~david/computers/quine.html#sec_second">second example</a> we have given on this page, to
which we add an intron.  Using this intron, the quine is able, when
passed a particular parameter, to produce a representation (valid in
the second programming language) of the two data sets (the actual data
of the quine and the intron) followed by some data specified by the
intron.  Then we do the same in the other programming language, with
the data representation we have elected to produce (and the second
program, when passed the special argument, must produce data
representation as we have used in the first program).  Finally, we
synchronize the introns: we use the intron of the first program to
represent the code of the second program and the intron of the second
to represent the code of the first.  (Remember, the nice thing about
introns is that we can change them <em>after</em> the quine has been
written, without removing its quinishness.)</p>

<p>If you would feel more comfortable with an example, I have written a
<a href="http://www.madore.org/~david/programs/selfrep/biquine.c">C/Perl</a> bi-quine.  (For
fun, I only give out the C version: if you want the Perl version you
will have to run the program with the <a href="http://foldoc.org/xyzzy">magic
word</a> as argument.)  In the C version, <code>c_data</code> is the
main data set and <code>perl_data</code> is an intron; in the Perl
version, of course, things are reversed.  (The coding is not quite the
same, also, although both are hexadecimal.)</p>


<h2 id="sec_bootstrap">Bootstrapping: recovering the code from
the data</h2>

<p>As we have already <a href="http://www.madore.org/~david/computers/quine.html#sec_princ">explained</a> and illustrated,
a quine is basically a bunch of data, plus an active part, the code,
which reads the data twice: once to reproduce the data, and once to
reproduce the code; the data represents the code, and the code
interprets that representation and recovers the code.  There are two
parts in the code: that which uses the data to copy the data and that
which uses the data to copy the code.</p>

<p>Now what if we are given only the data part of the quine?  In
the <a href="http://www.madore.org/~david/computers/quine.html#rmk_bioana">analogy</a> I have given with cellular
biology, this is the equivalent of having the DNA (the genome is what
I have been calling the “data”… ugh) and wanting to reconstruct a
cell.</p>

<p>Well, it is a matter of how difficult the coding (another word to
beware) is.  If I give you the following quine fragment (the data
part):</p>

<pre>const char data [] =
"#include &lt;stdio.h&gt;\n\nint\nmain (void)\n{\n  unsigned int i;\n\n  p"
"rintf (\"const char data [] =\");\n  for ( i=0 ; data[i] ; i++ "
")\n    {\n      if ( i%60 == 0 )\n\tprintf (\"\\n\\\"\");\n      switc"
"h ( data[i] )\n\t{\n\tcase '\\\\':\n\tcase '\"':\n\t  printf (\"\\\\%c\", d"
"ata[i]);\n\t  break;\n\tcase '\\n':\n\t  printf (\"\\\\n\");\n\t  break;\n"
"\tcase '\\t':\n\t  printf (\"\\\\t\");\n\t  break;\n\tdefault:\n\t  printf"
" (\"%c\", data[i]);\n\t}\n      if ( i%60 == 59 || !data[i+1] )\n\t"
"printf (\"\\\"\");\n    }\n  printf (\";\\n\\n\");\n  for ( i=0 ; data["
"i] ; i++ )\n    putchar (data[i]);\n  return 0;\n}\n";
</pre>

<p>you probably won't have much trouble recovering the <a href="http://www.madore.org/~david/programs/selfrep/yaq.c">complete quine</a>.  This is because
the representation chosen here is completely trivial.  We can proceed
as follows: just run the tiny instruction <code>printf ("%s",
data);</code> on the above data and you get the code; put the code and
the data together, and you get a first program which is almost the
quine (it may differ in inessential factors, for example if you put
the data after the code rather than before); but this program will
produce the original quine when run.  This process is called
<em>bootstrapping</em>, and it is similar to the process of
bootstrapping, say, a C compiler (you start with an initial C
compiler, which may be much simpler, much less featureful, or much
less efficient, than the C compiler you want to build, and you run it
on the sources of the desired C compiler, giving a first binary C
compiler, which you use a second time to recompile its own sources).</p>

<p>The possibility of bootstrapping means that to some extent quines are
self-healing: if the code is damaged but still able to use the data to
recover the original code, bootstrapping can be performed.</p>

<p id="rmk_coding">However, nothing says a quine must use a simple
coding like ASCII.  I have written <a href="http://www.madore.org/~david/programs/selfrep/selfunc.c">a quine</a> that stores, in its
data, a compressed (gzipped) representation of the code.  This means
that whereas the code that uses the data to produce the data is
trivial (it is the same as that used in our <a href="http://www.madore.org/~david/computers/quine.html#sec_second">previous example</a>), on the other hand the code
that uses the data to produce the code is much more involved, because
it must actually uncompress the data.  (The gzip format is very
strange and very unpleasant to uncompress.  I have written a set of
routines to decode it, which are included in the quine of course, and
which I put in the public domain if they can be useful to anyone.)
Here, the gzip program (plus a bit of interpreting the data as binary)
could serve to bootstrap.</p>

<p>Similarly, if I give you the following piece of data:</p>

<pre>const char data [] =
"#vapyhqr &lt;fgqvb.u&gt;\n\nvag\nznva (ibvq)\n{\n  hafvtarq vag v;\n\n  c"
"evags (\"pbafg pune qngn [] =\");\n  sbe ( v=0 ; qngn[v] ; v++ "
")\n    {\n      vs ( v%60 == 0 )\n\tcevags (\"\\a\\\"\");\n      fjvgp"
"u ( qngn[v] )\n\t{\n\tpnfr '\\\\':\n\tpnfr '\"':\n\t  cevags (\"\\\\%p\", q"
"ngn[v]);\n\t  oernx;\n\tpnfr '\\a':\n\t  cevags (\"\\\\a\");\n\t  oernx;\n"
"\tpnfr '\\g':\n\t  cevags (\"\\\\g\");\n\t  oernx;\n\tqrsnhyg:\n\t  cevags"
" (\"%p\", qngn[v]);\n\t}\n      vs ( v%60 == 59 || !qngn[v+1] )\n\t"
"cevags (\"\\\"\");\n    }\n  cevags (\";\\a\\a\");\n  sbe ( v=0 ; qngn["
"v] ; v++ )\n    {\n      vs ( ( qngn[v] &gt;= 'N' &amp;&amp; qngn[v] &lt; 'A"
"' )\n\t   || ( qngn[v] &gt;= 'n' &amp;&amp; qngn[v] &lt; 'a' ) )\n\tchgpune (q"
"ngn[v] + 13);\n      ryfr vs ( ( qngn[v] &gt;= 'A' &amp;&amp; qngn[v] &lt;="
" 'M' )\n\t\t|| ( qngn[v] &gt;= 'a' &amp;&amp; qngn[v] &lt;= 'm' ) )\n\tchgpune "
"(qngn[v] - 13);\n      ryfr\n\tchgpune (qngn[v]);\n    }\n  erghe"
"a 0;\n}\n";
</pre>

<p>you will have no trouble recovering the <a href="http://www.madore.org/~david/programs/selfrep/r13quine.c">original program</a> if you have
a little bit of geek culture, but you probably get my point anyway.</p>

<p id="rmk_keycode">In fact, let us take an extreme example: I
have written <a href="http://www.madore.org/~david/programs/selfrep/blowquine.c">a quine</a>
that stores its code enciphered with the blowfish cryptographic
algorithm (by Bruce Schneier) in its data.  Of course, the key is part
of the code (without the key, the data is useless).  Moreover, I have
added an <a href="http://www.madore.org/~david/computers/quine.html#rmk_intron">intron</a> to the program, which is
encrypted with the same key.  When the program is run with the <a href="http://foldoc.org/quine">magic
word</a> as argument, it deciphers (and prints) the intron rather than
printing its own listing.  This has an amusing consequence: if the key
is removed from the listing, then practically nothing is missing from
the code, and yet it is impossible to bootstrap; even though we have
most of the plain code, the complete ciphered data and secret, we
can't do much with it because all is locked by a key (and blowfish is
not known to be vulnerable to a known-plaintext attack).  In fact, the
situation is even more ironic than that since the key is present in
the crypted data: we are, essentially, in the situation of someone
locked outside his home with the key inside.</p>

<p><small>(Note that in writing this quine I have implemented the blowfish
encryption and decryption algorithm — in fact, the quine
contains the full functions, far more than are necessary for what it
does.  I put these functions in the public domain: you can find them
<a href="ftp://ftp.madore.org/pub/madore/misc/blowfish.c">here
without the quine part</a>.  <em>Be careful</em>: although I am using
this just for fun, this is nevertheless strong crypto.  So be careful
about your local crypto laws.)</small></p>

<p id="rmk_codedata">A point might be made here about the
distinction between code and data: here I claim that the key is part
of the <em>code</em> and not the <em>data</em>.  The difference is not
so much in how the key is used as in how it is stored.  In fact, if
the key is in the code (as in my quine) the program's skeleton is
basically this:</p>

<pre>/* See comments below */

const unsigned char data[] = {
<i>/* Lots of encrypted data corresponding to everything starting
 * from the next comment. */</i>
};

/* Code starts here */

<i>/* Decryption routines omitted. */</i>

const char key[] = "Foobar";

int
main (void)
{
  printf ("/* See comments below */\n\n");
  printf ("const unsigned char data[] = {\n");
  pretty_hexadecimal_printout (data);
  printf ("};\n\n");
  decipher (key, data);
  return 0;
}
</pre>

<p>and as explained, if the key is removed, it is “locked inside the
house”.  However, if we had some magical way of deciphering blowfish,
we could recover the key (even if our magical method did not let us do
this <i>a priori</i>) because it is part of the code, so it
is stored among the encrypted data.  On the other hand, if the key is
data, the program looks like this:</p>

<pre>/* See comments below */

const char key[] = "Foobar";

const unsigned char data[] = {
<i>/* Lots of encrypted data corresponding to everything starting
 * from the next comment. */</i>
};

/* Code starts here */

<i>/* Decryption routines omitted. */</i>

int
main (void)
{
  printf ("/* See comments below */\n\n");
  printf ("const char key[] = \"%s\";\n\n", key);
  printf ("const unsigned char data[] = {\n");
  pretty_hexadecimal_printout (data);
  printf ("};\n\n");
  decipher (key, data);
  return 0;
}
</pre>

<p>This may not appear very different, but it is.  This time, there isn't
a copy of the key “inside the house”.  The key is part of the data,
it is the only part of the data that is stored in clear.  I think
there is something to this idea of distinguishing the “code” and
“data” parts of a quine not by <em>what they are used for</em> but
<em>how they are printed</em>.</p>

<p>While it is true that some parts of the code can be recovered by a
bootstrapping process, on the other hand, the data can <em>never</em>
be recovered in that way.  Any part of a quine which, if it is
modified, does not change the program output (meaning that the program
output is still the original quine), is <em>not</em> <em>data</em>, it
is <em>code</em>.  (This applies, for example, to the comments inside
the data section of the program.)  (Well, all right, I guess there
<em>is</em> room for discussion.)</p>

<p>However, the data contains parts of a different nature: when they are
modified, the output produced by the program <em>is</em> modified, but
it <em>remains</em> a quine.  Those are the <a href="http://www.madore.org/~david/computers/quine.html#rmk_intron">introns</a> we have already much talked about.  In
a way, introns represent the exact opposite of the principle of
bootstrapping: in the case of bootstrapping, we hope that after a
certain number of iterations we will hit the original program again;
but if we modify an intron, the program remains a quine, so it will
not “heal” itself, it will just remain in its modified form.</p>


<h2 id="sec_recap">Recapitulation</h2>

<p>I have been introducing a great many names and concepts.  I will
summarize them here.</p>

<ul>

<li>A <a href="http://www.madore.org/~david/computers/quine.html#sec_intro"><dfn>quine</dfn></a> (or
<dfn>selfrep</dfn>) is a program that prints its own listing.</li>

<li>A <a href="http://www.madore.org/~david/computers/quine.html#sec_multiquine"><dfn>multi-quine</dfn></a> is a
collection of several quines, each one of which is able to print
either its own listing or any of the other ones.</li>

<li>The <a href="http://www.madore.org/~david/computers/quine.html#sec_princ"><dfn>code</dfn></a> section of a quine is
that which uses the data to print the program; it is printed by
interpreting the data section (which may imply unlocking it with a key
or some complicated operation of the sort).</li>

<li>The <a href="http://www.madore.org/~david/computers/quine.html#sec_princ"><dfn>data</dfn></a> section of a quine is
that which represents the code section.  It is derived from the
textual form of the code, and the code's role is to perform this
operation backward; the data is printed by reading the data and
representing it in a more or less trivial fashion (for example,
tabulating it in hexadecimal).</li>

<li>An <a href="http://www.madore.org/~david/computers/quine.html#rmk_intron"><dfn>intron</dfn></a> is a part of the
data section of a quine which can be modified in such a way that the
program <em>remain</em> a quine (in other words: it is modified and
the output produced by the program changes so as to follow the data
modification).</li>

<li><a href="http://www.madore.org/~david/computers/quine.html#rmk_miscode"><dfn>Irrelevant code</dfn></a> is a part of
the quine's code section which can be modified (or removed) so that
the program still produces the same output (<i>ergo</i> the
original quine).  In other words, <em>bootstrapping</em> the quine
will <em>heal</em> the irrelevant code.</li>

<li><a href="http://www.madore.org/~david/computers/quine.html#rmk_keycode"><dfn>Key code</dfn></a> is a part of the
quine's code section which cannot be modified at all (if it is
modified, the program either is not correct, or does not function, or
produces gibberish; this is in contrast with an intron which if
modified does not make the quine any less quinish, or irrelevant code
which if modified still produces the same program).</li>

<li><a href="http://www.madore.org/~david/computers/quine.html#sec_bootstrap"><dfn>Bootstrapping</dfn></a> is the
operation of running one or more times a modified version of a quine
to recover the original quine.  For example, a quine can be
boostrapped from the knowledge of its data section and of some code
that will perform the function of the key code.  This is a “healing”
process that will recover the irrelevant code.</li>

</ul>

<p>There are analogies with compilers (or interpreters) of course.  An
<em>intron</em> within a compiler would be something that cannot be
bootstrapped, essentially because the compiler (or interpreter) merely
copies the behavior of the underlying system (compiler) to itself.
This is what Ken Thompson explains (he gives the example of
<code>\v</code> in C) in his <a href="http://cm.bell-labs.com/who/ken/trust.html">Turing Award speech</a>
quoted in the <a href="http://www.madore.org/~david/computers/quine.html#sec_links">links section below</a>.
<em>Irrelevant code differences</em> are differences between two
compilers which perform the same task (i.e. output the same binaries)
but in a different way (<em>their</em> binaries are different), for
example the same compiler compiled with two different compilers; then
we can do a <em>bootstrapping</em>, i.e. recompile the compiler and
obtain the “fixed-point” version.</p>


<h2 id="sec_selfint">Self-interpretation: using data as
code</h2>

<p>In this section I must give my examples in Scheme rather than in C
because Scheme permits the manipulation of programs (meta-expressions)
as data (symbolic expressions).</p>

<p>Consider the two following elegant Scheme quine programs.  First this
one:</p>

<pre>(define (line-write x) (write x) (newline))
(define (d l) (map line-write l))
(define (mid) (display "(do '(") (newline))
(define (end) (display "))") (newline))
(define (do l) (d l) (mid) (d l) (end))
(do '(
(define (line-write x) (write x) (newline))
(define (d l) (map line-write l))
(define (mid) (display "(do '(") (newline))
(define (end) (display "))") (newline))
(define (do l) (d l) (mid) (d l) (end))
))
</pre>

<p>and second this one</p>

<pre>(define x '(
(display "(define x '(")
(newline)
(map (lambda (s) (write s) (newline)) x)
(display "))")
(newline)
(display "(map eval x)")
(newline)
))
(map eval x)
</pre>

<p>The first one is easy enough to understand, and follows the usual
pattern well: the five lines ending with the second-to-last are the
“data” (as well as the two character strings, I suppose), and the
rest is the “code”.  The code (the <code>do</code> function
essentially) uses the data (the <code>l</code> variable essentially)
to print the code (the first <code>(d l)</code>) and then print the
data (the second <code>(d l)</code>).</p>

<p>But the second example is a bit strange: evidently the <code>x</code>
variable (the lines from the second to the eight) is data.  The code,
essentially, is limited to the single instruction <code>(map eval
x)</code>.  If you are unfamiliar with Scheme, this means: “consider
<code>x</code> as a list of Scheme instructions and execute them”.
So what we are doing here is using the data, in effect, as code.  This
is curious because the whole point of a quine, really is to use
<em>code</em> as <em>data</em> and here we are using <em>data</em> as
<em>code</em>.  But in a way it makes sense: if you consider
<code>x</code> to be written in a programming language which is just
like Scheme except that the code can be accessed as data…
through the variable <code>x</code>!  Then <code>x</code>'s rôle is to
print <code>x</code> itself plus the “interpreter” (<code>(map eval
x)</code>).</p>

<p>I have also written a <a href="http://www.madore.org/~david/programs/selfrep/selfrep2.5.sh">quine
in Bourne shell</a> along the same principles.  It is rather subtle to
understand, but I think it is worth the trouble.  If you prefer the
“dc” programming languages, the compare <a href="http://www.madore.org/~david/programs/selfrep/selfrep1.dc">this quine</a> (along the lines
of the first Scheme program above, i.e. the “normal” lines) and <a href="http://www.madore.org/~david/programs/selfrep/selfrep3.dc">that one</a> (which also uses
the data-as-code principle and it is shorter).</p>

<p>I'm not entirely sure whether this way of writing quines is actually
<em>qualitatively</em> different from the “normal” way.
(For example, do they correspond to a different proof of the <a href="http://www.madore.org/~david/computers/quine.html#sec_fp">fixed-point</a> theorem, perhaps one that uses one more
time the universality theorem — I can manufacture such a proof
but it is not really convincing.)  It is true that if we compare the
two Scheme programs, or the two dc programs, given above, there seems
to be an important difference (namely, that there is much more
redundancy in the first shan in the second).  But maybe that is just a
naïve way of thinking.  Still, I can't help but think there is some
relation with the two ways of writing the Curry Y (fixed-point)
combinator: as λf.((λx.(f(xx)))(λx.(f(xx)))) or
as λf.((λx.(xx))(λx.(f(xx)))).  But maybe I'm
gone totally off my rocker there.</p>

<p id="rmk_selfint">To conclude this section, I'd like to
mention one <a href="http://www.madore.org/~david/programs/self-int.scm">program I wrote</a>
that I'm particularly fond of.  It is not a quine and it is in no way
so impressive; but in fact it was considerably more difficult to write
than a quine.  It consists of a (rather minimal) Scheme interpreter,
written in Scheme.  And that interpreter is applied to itself acting
upon itself.  So it is a Scheme interpreter trying to interpret a
Scheme interpreter interpreting a Scheme interpreter
interpreting… well, you get the picture.  As each interpreter
prints some debugging information about the program it is
interpreting, this leads to a lot of output data (with curious
properties; for example, search for the string “Now starting
evaluation…” without quotes around it, and see how it
becomes logarithmically rarer and rarer).  If you have read the <a href="http://www.madore.org/~david/computers/quine.html#rmk_univfp">cryptic comment</a> I have made a while back on the
use of the universality theorem in the fixed-point theorem, this is a
case were we <em>need</em> the universality theorem, and indeed, it is
the central part of our program (writing an interpreter).  You should
also note the analogy with Gödel's theorem, because this
self-interpreting program is much closer to Gödel's theorem than
ordinary quines.  Naturally, if we allow the use of the
<code>eval</code> function (but that's cheating), we can rewrite my
program in a much simpler way:</p>

<pre>((lambda (expr) (eval `(,expr ,expr)))
 '(lambda (expr) (eval `(,expr ,expr))))
</pre>

<p>(a cute endless loop).</p>


<h2 id="sec_conc">Conclusion</h2>

<p>Well, I've written much more than I intended to.  I wanted to make
this a small page on The Art Of Quine Programming, and it turned out
to be quine (oh, what a strange slip!  I meant “quite” of course) a
monument.</p>

<p>I haven't given enormously many examples, but I hope the examples I've
given were clear enough so that, if you didn't know how to write
quines initially, now you do (even if you didn't understand all that's
on this page).  If you want more examples, have a look at my <a href="http://www.madore.org/~david/programs/selfrep/">personal quines collection</a> (all
written by yours truly), which you can also access by <a href="ftp://ftp.madore.org/pub/madore/selfrep/selfrep/">FTP</a>,
or download as a single <a href="ftp://ftp.madore.org/pub/madore/selfrep/selfrep.tgz">tarball</a>.
Also look at some of the <a href="http://www.madore.org/~david/computers/quine.html#sec_links">links</a> below, where a
great number of more quines can be found.</p>

<p>Yow!  I've just lost the SOURCE CODE for all my QUINE PROGRAMS!  What
will I DO NOW with just the BINARIES?</p>


<h2 id="sec_links">Links related to quines</h2>

<ul>

<li>The <a href="http://dmoz.org/Computers/Programming/Metaprogramming/Quines/">Quines</a>
node in the <a href="http://dmoz.org/">Open Directory</a></li>

<li>The <a href="http://foldoc.doc.ic.ac.uk/foldoc/foldoc.cgi?query=quine">quine
entry</a> of the <a href="http://foldoc.doc.ic.ac.uk/foldoc/">FOLDOC</a></li>

<li>The <a href="http://en.wikipedia.org/wiki/Quine">“Quine”
entry</a> in the <a href="http://en.wikipedia.org/">Wikipedia</a></li>

<li>The <a href="http://www.everything2.org/index.pl?node=quine">“quine”
node</a> on <a href="http://www.everything2.org/">Everything2</a></li>

<li>The <a href="http://www.nyx.net/~gthompso/quine.htm">Quine
Page</a> by Gary P. Thompson&nbsp;II</li>

<li>About the <a href="http://www.madore.org/~david/programs/unlambda/#quine">Unlambda Quine
Contest</a></li>

<li>My personal <a href="ftp://ftp.madore.org/pub/madore/selfrep/">collection of
quines</a> (quite small in comparison with those of Ben Olmstead or
Gary P. Thompson&nbsp;II)</li>

<li>An <a href="http://www.madore.org/~david/misc/best_of_GroTeXdieck/selfrep">explanation</a>
of the above collection I posted on a local newsgroup of the ENS (so
it's in French)</li>

<li>A famous text (somewhat distantly related): Ken Thompson's Turing
Award speech, <a href="http://cm.bell-labs.com/who/ken/trust.html"><cite>Reflections on
Trusting Trust</cite></a></li>

</ul>



<footer class="cleared"><hr>
<div id="js-foot-space"><!-- To be filled by JavaScript --><div lang="en"><p><button>⚙</button>&nbsp;←&nbsp;Click for site settings</p><div id="js-site-settings" style="display: none;"><p lang="en">Change site font size (current: <span id="js-show-current-font-size">16px</span>): <button>reset</button> (default: <span id="js-show-default-font-size">16px</span>), <button>8px</button>&nbsp;<span style="font-size: 8px;">(Aa)</span>, <button>9px</button>&nbsp;<span style="font-size: 9px;">(Aa)</span>, <button>10px</button>&nbsp;<span style="font-size: 10px;">(Aa)</span>, <button>11px</button>&nbsp;<span style="font-size: 11px;">(Aa)</span>, <button>12px</button>&nbsp;<span style="font-size: 12px;">(Aa)</span>, <button>13px</button>&nbsp;<span style="font-size: 13px;">(Aa)</span>, <button>14px</button>&nbsp;<span style="font-size: 14px;">(Aa)</span>, <button>15px</button>&nbsp;<span style="font-size: 15px;">(Aa)</span>, <button>16px</button>&nbsp;<span style="font-size: 16px;">(Aa)</span>, <button>17px</button>&nbsp;<span style="font-size: 17px;">(Aa)</span>, <button>18px</button>&nbsp;<span style="font-size: 18px;">(Aa)</span>, <button>19px</button>&nbsp;<span style="font-size: 19px;">(Aa)</span>, <button>20px</button>&nbsp;<span style="font-size: 20px;">(Aa)</span>, <button>22px</button>&nbsp;<span style="font-size: 22px;">(Aa)</span>, <button>24px</button>&nbsp;<span style="font-size: 24px;">(Aa)</span>, <button>26px</button>&nbsp;<span style="font-size: 26px;">(Aa)</span>, <button>28px</button>&nbsp;<span style="font-size: 28px;">(Aa)</span>, <button>30px</button>&nbsp;<span style="font-size: 30px;">(Aa)</span>, <button>32px</button>&nbsp;<span style="font-size: 32px;">(Aa)</span></p><p lang="en">Change site line size (current: <span id="js-show-current-max-width">infinite</span>): <button>reset</button> (default: infinite), <button>50ch</button>, <button>60ch</button>, <button>70ch</button>, <button>80ch</button>, <button>90ch</button>, <button>100ch</button>, <button>110ch</button>, <button>120ch</button>, <button>130ch</button>, <button>140ch</button>, <button>150ch</button>, <button>160ch</button>, <button>infinite</button></p></div></div></div><hr>
<address class="author vcard"><a class="url fn" href="http://www.madore.org/~david/">David Madore</a> (<a class="despammed-address" href="mailto:david+www@madore.org"><code class="despammed-email">david+www@madore.org</code></a><wbr>|<a href="http://www.madore.org/~david/ego.html" rel="author">⁂</a><wbr>|<a href="https://twitter.com/gro_tsen" rel="me">Twitter</a><wbr>|<a href="https://bsky.app/profile/gro-tsen.bsky.social" rel="me">Bluesky</a><wbr>|<a href="https://mastodon.sdf.org/@gro_tsen_test" rel="me">Mastodon (test)</a><wbr>|<a href="https://www.reddit.com/user/Gro-Tsen/" rel="me">Reddit</a><wbr>|<a href="http://www.facebook.com/grotsen" rel="me">Facebook (unused)</a>)</address>
</footer>


</body></html>